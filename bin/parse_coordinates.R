#!/usr/bin/Rscript
#########################################################################
##                                                                     ##
##     parse_coordinates.R                                             ##
##                                                                     ##
##     Gael A. Millot                                                  ##
##     Chloe Taurel                                                    ##
##     Bioinformatics and Biostatistics Hub                            ##
##     Institut Pasteur Paris                                          ##
##                                                                     ##
#########################################################################




################################ Aim

# Parse the coordinates of FR1, CDR1, FR2, CDR2, FR3, and CDR3 features from a .fmt7 file generated by igblast
# These coordinates will then be used to annotate mentionned features on alignment displays of ig sequences


################################ End Aim


################################ Introduction


################################ End Introduction


################################ Acknowlegments


################################ End Acknowlegments


################################ Initialization


# R version checking
if(version$version.string != "R version 4.1.2 (2021-11-01)"){
    stop(paste0("\n\n================\n\nERROR IN parse_coordinates.R\n\n\n", version$version.string, " IS NOT THE 4.1.2 RECOMMANDED\n\n================\n\n"))
}
# other initializations
erase.objects = TRUE # write TRUE to erase all the existing objects in R before starting the algorithm and FALSE otherwise. Beginners should use TRUE
if(erase.objects == TRUE){
    rm(list = ls(all.names = TRUE))
    erase.objects = TRUE
}
erase.graphs = TRUE # write TRUE to erase all the graphic windows in R before starting the algorithm and FALSE otherwise
script <- "parse_coordinates.R"


################################ End Initialization


################################ Parameters that need to be set by the user


################################ End Parameters that need to be set by the user


################################ Config import


tempo.cat <- "KIND OF RUN (SCRIPT, COPY-PASTE OR SOURCE): "
if(interactive() == FALSE){ # if(grepl(x = commandArgs(trailingOnly = FALSE), pattern = "R\.exe$|\/R$|Rcmd\.exe$|Rcmd$|Rgui\.exe$|Rgui$|Rscript\.exe$|Rscript$|Rterm\.exe$|Rterm$")){ # detection of script usage
    run.way <- "SCRIPT"
    cat(paste0("\n\n", tempo.cat, run.way, "\n"))
    command <- paste0(commandArgs(trailingOnly = FALSE), collapse = ",") # recover the full command
    args <- commandArgs(trailingOnly = TRUE) # recover arguments written after the call of the R script
    if(any(is.na(args))){
        stop(paste0("\n\n================\n\nERROR IN ", script, "\n\n\nTHE args OBJECT HAS NA\n\n================\n\n"), call. = FALSE)
    }
    tempo.arg.names <- c(
        "tsv_name",
        "fmt7_name",
        "cute",
        "log"
    )
    if(length(args) != length(tempo.arg.names)){
        stop(paste0("\n\n================\n\nERROR IN ", script, "\n\n\nTHE NUMBER OF ELEMENTS IN args (", length(args),") IS DIFFERENT FROM THE NUMBER OF ELEMENTS IN tempo.arg.names (", length(tempo.arg.names),")\nargs:", paste0(args, collapse = ","), "\ntempo.arg.names:", paste0(tempo.arg.names, collapse = ","), "\n\n================\n\n"), call. = FALSE)
    }
    for(i1 in 1:length(tempo.arg.names)){
        assign(tempo.arg.names[i1], args[i1])
    }
    rm(args, i1)
}else if(sys.nframe() == 0L){ # detection of copy-paste/direct execution (for debugging). With script it is also 0, with source, it is 4
    run.way <- "COPY-PASTE"
    cat(paste0("\n\n", tempo.cat, run.way, "\n"))
}else{
    run.way <- "SOURCE" # using source(), sys.nframe() is 4
    cat(paste0("\n\n", tempo.cat, run.way, "\n"))
}
rm(tempo.cat)


################################ End Config import

### Test

# setwd("C:/Users/ctaurel/Documents/Rtest")
# file <- "VH_8997.fmt7"

################################ Recording of the initial parameters


param.list <- c(
    "erase.objects", 
    "erase.graphs", 
    "script", 
    "run.way",
    "tempo.arg.names", 
    if(run.way == "SCRIPT"){"command"}, 
    "tsv_name",
    "fmt7_name",
    "cute",
    "log"
)
if(any(duplicated(param.list))){
    stop(paste0("\n\n================\n\nINTERNAL CODE ERROR 1 IN ", script, "\n\nTHE param.list OBJECT CONTAINS DUPLICATED ELEMENTS:\n", paste(param.list[duplicated(param.list)], collapse = " "), "\nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n================\n\n"), call. = FALSE) # message for developers
}
if(erase.objects == TRUE){
    created.object.control <- ls()[ ! ls() %in% "param.list"]
    if( ! (all(created.object.control %in% param.list) & all(param.list %in% created.object.control))){
        stop(paste0("\n\n================\n\nINTERNAL CODE ERROR 2 IN ", script, "\n\nINCONSISTENCIES BETWEEN THE ARGUMENTS USED AND THE PARAMETERS REQUIRED IN THE EXECUTABLE CODE FILE\nTHE ARGUMENTS NOT PRESENT IN THE EXECUTABLE FILE (", script, ") ARE:\n", paste(created.object.control[ ! created.object.control %in% param.list], collapse = " "), "\nTHE PARAMETERS OF THE EXECUTABLE FILE (", script, ") NOT PRESENT IN THE ARGUMENTS ARE:\n", paste(param.list[ ! param.list %in% created.object.control], collapse = " "), "\nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n================\n\n"), call. = FALSE) # message for developers
    }
}
char.length <- nchar(param.list)
space.add <- max(char.length) - char.length + 5
param.ini.settings <- character(length = length(param.list))
for(i in 1:length(param.list)){
    param.ini.settings[i] <- paste0("\n", param.list[i], paste0(rep(" ", space.add[i]), collapse = ""), paste0(get(param.list[i]), collapse = ",")) # no env = sys.nframe(), inherit = FALSE in get() because look for function in the classical scope
}


################################ End Recording of the initial parameters


################################ Functions


################ import functions from cute little functions toolbox


if(length(cute) != 1){
    stop(paste0("\n\n============\n\nERROR IN ", script, "\ncute PARAMETER MUST BE LENGTH 1: ", paste(cute, collapse = " "), "\n\n============\n\n"), call. = FALSE)
}else if(grepl(x = cute, pattern = "^http")){
    tempo.try <- try(suppressWarnings(suppressMessages(source(cute, local = .GlobalEnv))), silent = TRUE)
    if(any(grepl(x = tempo.try, pattern = "^[Ee]rror"))){
        stop(paste0("\n\n============\n\nERROR IN ", script, "\nHTTP INDICATED IN THE cute PARAMETER DOES NOT EXISTS: ", cute, "\n\n============\n\n"), call. = FALSE)
    }else{
        source(cute, local = .GlobalEnv) # source the fun_ functions used below
    }
}else if( ! grepl(x = cute, pattern = "^http")){
    if( ! file.exists(cute)){
        stop(paste0("\n\n============\n\nERROR IN ", script, "\nFILE INDICATED IN THE cute PARAMETER DOES NOT EXISTS: ", cute, "\n\n============\n\n"), call. = FALSE)
    }else{
        source(cute, local = .GlobalEnv) # source the fun_ functions used below
    }
}else{
    tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 3 IN ", script, ":\nCODE HAS TO BE MODIFIED\nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n============\n\n")
    stop(tempo.cat, call. = FALSE)
}

################ local function: package import


################ local function


################################ End Functions


################################ Pre-ignition checking


# reserved words
# end reserved words
# argument primary checking
arg.check <- NULL #
text.check <- NULL #
checked.arg.names <- NULL # for function debbuging: used by r_debugging_tools
ee <- expression(arg.check <- c(arg.check, tempo$problem) , text.check <- c(text.check, tempo$text) , checked.arg.names <- c(checked.arg.names, tempo$object.name))
for(i0 in tempo.arg.names){
    tempo <- fun_check(data = get(i0), class = "vector", typeof = "character", length = 1) ; eval(ee)
}
if(any(arg.check) == TRUE){ # normally no NA
    stop(paste0("\n\n================\n\n", paste(text.check[arg.check], collapse = "\n"), "\n\n================\n\n"), call. = FALSE) # == in stop(), not in tempo.cat, to be able to add several messages between == #
}
# end argument primary checking
# second round of checking and data preparation
# management of NA arguments
# end management of NA arguments


# seed
set.seed(1)
# end seed
# warning initiation
ini.warning.length <- options()$warning.length
options(warning.length = 8170)
warn <- NULL
# warn.count <- 0 # not required
# end warning initiation
# other checkings (not full checked because already checked in the .nf file)
if( ! file.exists(fmt7_name)){
    tempo.cat <- paste0("ERROR IN ", script, ":\nTHE fmt7_name PARAMETER MUST BE A VALID PATH OF A FILE IS NOT \"NULL\"\nHERE IT IS: \n", paste0(fmt7_name, collapse = " "))
    stop(paste0("\n\n================\n\n", tempo$text, "\n\n================\n\n"), call. = FALSE)
}
if( ! file.exists(tsv_name)){
    tempo.cat <- paste0("ERROR IN ", script, ":\nTHE tsv_name PARAMETER MUST BE A VALID PATH OF A FILE IS NOT \"NULL\"\nHERE IT IS: \n", paste0(tsv_name, collapse = " "))
    stop(paste0("\n\n================\n\n", tempo$text, "\n\n================\n\n"), call. = FALSE)
}


# other checkings (not full checked because already checked in the .nf file)
# reserved word checking
# end reserved word checking
# end second round of checking and data preparation
# package checking
# end package checking


################################ End pre-ignition checking


################################ Main code


################ Ignition


fun_report(data = paste0("\n\n################################################################ ParseCoordinates PROCESS\n\n"), output = log, path = "./", overwrite = FALSE)
ini.date <- Sys.time()
ini.time <- as.numeric(ini.date) # time of process begin, converted into seconds
fun_report(data = paste0("\n\n################################ RUNNING DATE AND STARTING TIME\n\n"), output = log, path = "./", overwrite = FALSE)
fun_report(data = paste0(ini.date, "\n\n"), output = log, path = "./", overwrite = FALSE)
fun_report(data = paste0("\n\n################################ RUNNING\n\n"), output = log, path = "./", overwrite = FALSE)


################ End ignition

lines <- readLines(fmt7_name)
tsv <- read.table(tsv_name, sep = "\t", header = TRUE)

# Test if "0 hits found" or "Query:" line is empty ; then no tsv is made (means no gene matches were found or no sequence_id visible)
query_line_idx <- grep("^# Query:", lines)
if (length(query_line_idx) == 0) { 
    tempo.cat <- paste0("ERROR IN ", script, ":\nTHE fmt7_name PARAMETER MUST BE IN THE igblast OUTPUT FORMAT AND THEREFORE SHOULD HAVE A LINE STARTING WITH \"# Query:\" (HERE IT IS NOT THE CASE) \nHERE IT IS: \n", paste0(lines, collapse = "\n"))
    stop(tempo.cat, call. = FALSE)
}
sequence_id <- sub("^# Query: *", "", lines[query_line_idx])
if (sequence_id == "") {
    tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 4 IN ", script, ":\n\nTHE fmt7_name PARAMETER MUST BE IN THE igblast OUTPUT FORMAT AND THEREFORE SHOULD HAVE A LINE STARTING WITH \"# Query:\" \n THE EXISTENCE OF THIS LINE HAS BEEN TESTED AND VERIFIED, BUT ITS POSITION INDEX COULD NOT BE FOUND. \nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n============\n\n")
    stop(tempo.cat, call. = FALSE)
}
if (length(grep("^# 0 hits found", lines)) > 0) {
    tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 5 IN ", script, ":\n\nNO HITS WERE FOUND FOR THE ", sequence_id, " SEQUENCE, THEREFORE THERE ARE NO COORDINATES TO PARSE.\nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n================\n\n")
    stop(tempo.cat, call. = FALSE)
}

# The wanted info is in the section after "# Alignment summary" column 
start_idx <- grep("^# Alignment summary", lines)
if (length(start_idx) == 0 ){
    tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 6 IN ", script, ":\n\nNO \"# Alignment summary\" SECTION FOUND IN THE .fmt7 INPUT FILE, THEREFORE THERE ARE NO COORDINATES TO PARSE.\nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n================\n\n")
    stop(tempo.cat, call. = FALSE)
}
tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 7 IN ", script, ":\n\nTHE fmt7_name PARAMETER MUST BE IN THE igblast OUTPUT FORMAT AND THEREFORE SHOULD HAVE A LINE STARTING WITH \"# Query:\" \n THE EXISTENCE OF THIS LINE HAS BEEN TESTED AND VERIFIED, BUT ITS POSITION INDEX COULD NOT BE FOUND. \nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n============\n\n")
section_start <- start_idx + 1
total_idx <- grep("^Total", lines)
section_end <- min(total_idx[total_idx > section_start]) # Section ends at the first line starting with "Total" after "# Alignment summary", min will return "Inf" is total_idx is empty
if(!is.integer(section_end)) { # Indicates that no line starting with "Total" was found. Then the section end is either the next empty line or the end of the file
    empty_line <- which(lines == "")
    empty_after_start <- empty_line[empty_line > section_start]
    if(length(empty_after_start) > 0) {
        section_end <- min(empty_after_start) - 1
    } else {
        section_end <- length(lines)
    }
} else {
    section_end <- section_end - 1
}

align_lines <- lines[section_start:section_end] # Extract the wanted section
align_lines <- align_lines[!grepl("^#|^$|^Total", align_lines)] # Last verification that no empty lines or line starting with "#" or "Total" remain
if (length(align_lines) == 0) {
    tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 8 IN ", script, ":\n\nTHE fmt7_name PARAMETER MUST BE IN THE igblast OUTPUT FORMAT AND THEREFORE SHOULD HAVE AN \"# Alignment summary\" \n SECTION. SEVERAL TESTS WERE MADE TO ENSURE ITS EXISTENCE, BUT THE SECTION WAS FOUND EMPTY. \nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n============\n\n")
    stop(tempo.cat, call. = FALSE)
}

tab <- do.call(rbind, strsplit(align_lines, "\t"))

# Named list for expected regions, the ones that are actually present in the fmt7 file and the tsv future column names
expected_regions <- c("FR1-IMGT", "CDR1-IMGT", "FR2-IMGT", "CDR2-IMGT", "FR3-IMGT", "CDR3-IMGT (germline)")
present_regions <- tab[,1] # First column of tab contains region names present in fmt7 file
wanted_labels <- c("FR1", "CDR1", "FR2", "CDR2", "FR3", "CDR3")

if(!all(expected_regions %in% present_regions)){
    tempo.cat <- paste0("\n\n================\n\nWARNING :\n\nTHE fmt7_name PARAMETER MUST BE IN THE igblast OUTPUT FORMAT AND THEREFORE SHOULD HAVE AN \"# Alignment summary\" \n SECTION STARTING WITH THE FOLLOWING LINES: ", paste0(expected_regions, collapse = " ; "), "\nHOWEVER, HERE ARE THE LINES IN THE ", fmt7_name, "FILE : \n ", paste0(tab[,1], collapse = " ; "), " \nNA VALUES WERE PLACED IN THE COLUMNS TO THE CORRESPONDING MISSING LINES\n\n============\n\n")
    cat(tempo.cat, file = log, append = TRUE)
}
if (!all(present_regions %in% expected_regions)){
    tempo.cat <- paste0("\n\n================\n\nINTERNAL CODE ERROR 9 IN ", script, ":\n\n\"# Alignment summary\" \n SECTION IN THE fmt7_name PARAMETER CONTAINS A LINE STARTING WITH \"", present_regions[i], "\"\nTHIS SECTION SHOULD ONLY CONTAIN LINES STARTING WITH THE FOLLOWING STRINGS: ", paste0(expected_regions, collapse = " ; "), "\nPLEASE, SEND AN ISSUE AT https://gitlab.pasteur.fr/gmillot/repertoire_profiler OR REPORT AT gael.millot@pasteur.fr\n\n============\n\n")
    stop(tempo.cat, call. = FALSE)
}

coords <- list()
for (i in seq_along(expected_regions)) {
    match_index <- which(present_regions == expected_regions[i])
    if (length(match_index) == 1) {
        coords[[paste0(wanted_labels[i], "_start")]] <- as.integer(tab[match_index,2])
        coords[[paste0(wanted_labels[i], "_end")]]   <- as.integer(tab[match_index,3])
    } else {
        coords[[paste0(wanted_labels[i], "_start")]] <- NA
        coords[[paste0(wanted_labels[i], "_end")]]   <- NA
    }
}


df <- data.frame(sequence_id = sequence_id,
                 FR1_start = coords$FR1_start, FR1_end = coords$FR1_end,
                 CDR1_start = coords$CDR1_start, CDR1_end = coords$CDR1_end,
                 FR2_start = coords$FR2_start, FR2_end = coords$FR2_end,
                 CDR2_start = coords$CDR2_start, CDR2_end = coords$CDR2_end,
                 FR3_start = coords$FR3_start, FR3_end = coords$FR3_end,
                 CDR3_start = coords$CDR3_start, CDR3_end = coords$CDR3_end,
                 stringsAsFactors = FALSE)

tsv2 <- merge(tsv, df, by = "sequence_id", all.x = TRUE)

write.table(tsv2, file = paste0(sequence_id, "_coord_all_igblast_db-pass.tsv"), sep = "\t", quote = FALSE, row.names = FALSE)