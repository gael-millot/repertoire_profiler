// Compares input fasta files with reference files to determine which cassettes are present
// Output :
// - TUPLE db_pass_ch : *_igblast_db-pass.tsv : tsv files with the sequences aligned with the reference files (annotated by igblast)
//                                              file used in the next process
//                      *fmt7 : files generated by AssignGenes.py, contain various info about the v, j and/or d hits found from the imgt database
//                              in particular, these files contain the coordinates for start & end of ig gene regions (CDR1, FR1...)
//                 => emitted as a tuple to keep fmt7 files with their corresponding tsv
// - igblast_aligned_seq.tsv: names of the sequences aligned with the reference files
// - igblast_unaligned_seq.tsv: names of the sequences not aligned with the reference files
process Igblast_query {
    label 'immcantation'
    //publishDir path: "${out_path}", mode: 'copy', overwrite: false
    cache 'true'

    input:
    path fs_ch // parallelization expected (for each fasta file)
    val igblast_variable_ref_files
    val igblast_organism
    val igblast_loci

    output:
    path "*igblast_aligned_seq.tsv", emit: db_pass_ch
    path "*igblast_unaligned_seq.tsv", emit: db_unpass_ch
    path "*.log", emit: log_ch, optional: true

    script:
    """
    #!/bin/bash -ue

    # variables
    REPO_PATH="/usr/local/share/germlines/imgt/${igblast_organism}/vdj" # path where the imgt_human_IGHV.fasta, imgt_human_IGHD.fasta and imgt_human_IGHJ.fasta files are in the docker container
    VDJ_FILES=\$(awk -v var1="${igblast_variable_ref_files}" -v var2="\${REPO_PATH}" 'BEGIN{ORS=" " ; split(var1, array1, " ") ; for (key in array1) {print var2"/"array1[key]}}')
    FILENAME=\$(basename -- "${fs_ch}") # recover a file name without path
    FILE=\${FILENAME%.*} # file name without extension
    MODIF_FILE="\${FILE// /_}" # spaces in the name file replaced by _
    FILE="\${MODIF_FILE}"
    FILE_EXTENSION="\${FILENAME##*.}" #  ## means "delete the longest regex starting at the beginning of the tested string". If nothing, delete nothing. Thus ##*. means delete the longest string finishing by a dot. Use # instead of ## for "delete the shortest regex starting at the beginning of the tested string"
    echo -e "\\n\\n################################\\n\\n\$FILENAME\\n\\n################################\\n\\n" |& tee -a igblast_report.log
    echo -e "WORKING FOLDER:\\n\$(pwd)\\n\\n" |& tee -a igblast_report.log
    # end variables

    # checks
    if [[ ! "\${FILE_EXTENSION}" =~ fasta|fa|fas|fna|txt|seq ]] ; then
        echo -e "\\n\\n========\\n\\nERROR IN NEXTFLOW EXECUTION\\n\\nINVALID FILE EXTENSION IN THE sample_path PARAMETER OF THE nextflow.config FILE:\\n${fs_ch}\\n\${FILENAME}\\nMUST BE fasta|fa|fas|fna|txt|seq|faa\\n\\n========\\n\\n"
        exit 1
    fi
    sed 's/\\r\$//' ${fs_ch} > tempo_file.fasta # remove carriage returns
    awk 'BEGIN{ORS=""}{if(\$0~/^>.*/){s=substr(\$0,1,1); rest=substr(\$0,2); gsub(/[^a-zA-Z0-9]/,"_",rest) ; if(NR>1){print "\\n"} ; if (length(rest) > 100){print s substr(rest,1,100)"\\n"}else{print s rest"\\n"}} else {print \$0 ; next}}END{print "\\n"}' tempo_file.fasta > \${FILE}.fa # remove \\n in the middle of the sequence # gsub(/[^a-zA-Z0-9]/,"_",rest) replace any weird chars in the first line by a single underscore# \${FILENAME}.fa is a trick to do not use ${fs_ch} and modify the initial file due to the link in the nextflow work folder
    TEMPO=\$(wc -l \${FILE}.fa | cut -f1 -d' ')
    if read -n 1 char <"\${FILE}.fa"; [[ \$char != ">" || \$TEMPO != 2 ]]; then
        echo -e "\\n\\n========\\n\\nERROR IN NEXTFLOW EXECUTION\\n\\nINVALID FASTA FILE IN THE sample_path OF THE nextflow.config FILE:\\n${fs_ch}\\nMUST BE A FASTA FILE (\'>\' AS FIRST CHARACTER) MADE OF A SINGLE SEQUENCE\\n\\n========\\n\\n"
        exit 1
    fi
    # end checks

    # Alignment <-> annotate sequence using VDJ info
    # See https://changeo.readthedocs.io/en/stable/tools/AssignGenes.html for the details
    AssignGenes.py igblast -s \${FILE}.fa -b /usr/local/share/igblast --organism ${igblast_organism} --loci ${igblast_loci} --format blast |& tee -a igblast_report.log # *_igblast.fmt7
    AssignGenes.py igblast -s \${FILE}.fa -b /usr/local/share/igblast --organism ${igblast_organism} --loci ${igblast_loci} --format airr |& tee -a igblast_report.log # output is *_igblast.tsv
    # convert to tsv
    # Also convert data from the web interface IMGT/HighV-QUEST
    MakeDb.py igblast -i ./\${FILE}_igblast.fmt7 -s ./\${FILE}.fa -r \${VDJ_FILES} --extended -o blast_format.tsv |& tee -a igblast_report.log
    # end convert to tsv
    # test that the AssignGenes.py igblast --format airr is ok
    expected="sequence_id	sequence	sequence_aa	locus	stop_codon	vj_in_frame	v_frameshift	productive	rev_comp	complete_vdj	d_frame	v_call	d_call	j_call	c_call	sequence_alignment	germline_alignment	sequence_alignment_aa	germline_alignment_aa	v_alignment_start	v_alignment_end	d_alignment_start	d_alignment_end	j_alignment_start	j_alignment_end	c_alignment_start	c_alignment_end	v_sequence_alignment	v_sequence_alignment_aa	v_germline_alignment	v_germline_alignment_aa	d_sequence_alignment	d_sequence_alignment_aa	d_germline_alignment	d_germline_alignment_aa	j_sequence_alignment	j_sequence_alignment_aa	j_germline_alignment	j_germline_alignment_aa	c_sequence_alignment	c_sequence_alignment_aa	c_germline_alignment	c_germline_alignment_aa	fwr1	fwr1_aa	cdr1	cdr1_aa	fwr2	fwr2_aa	cdr2	cdr2_aa	fwr3	fwr3_aa	fwr4	fwr4_aa	cdr3	cdr3_aa	junction	junction_length	junction_aa	junction_aa_length	v_score	d_score	j_score	c_score	v_cigar	d_cigar	j_cigar	c_cigar	v_support	d_support	j_support	c_support	v_identity	d_identity	j_identity	c_identity	v_sequence_start	v_sequence_end	v_germline_start	v_germline_end	d_sequence_start	d_sequence_end	d_germline_start	d_germline_end	j_sequence_start	j_sequence_end	j_germline_start	j_germline_end	c_sequence_start	c_sequence_end	c_germline_start	c_germline_end	fwr1_start	fwr1_end	cdr1_start	cdr1_end	fwr2_start	fwr2_end	cdr2_start	cdr2_end	fwr3_start	fwr3_end	fwr4_start	fwr4_end	cdr3_start	cdr3_end	np1	np1_length	np2	np2_length"
    if [[ -s ./\${FILE}_igblast.tsv ]]; then # -s means --format airr has worked
        read -r firstline < ./\${FILE}_igblast.tsv
        if [[ "\$firstline" != "\$expected" ]]; then
            echo -e "\\n\\n========\\n\\nINTERNAL ERROR IN NEXTFLOW EXECUTION\\n\\nTHE COMANND AssignGenes.py igblast --format airr DOES NOT RETURN THE EXPECTED COLUMN NAMES\\n\\nPLEASE, REPORT AN ISSUE HERE https://gitlab.pasteur.fr/gmillot/repertoire_profiler/-/issues OR AT gael.millot<AT>pasteur.fr.\\n\\n"
            echo -e "COLUMN NAMES:\n \$firstline \\n\\n"
            echo -e "EXPECTED COLUMN NAMES:\n \$expected"
            echo -e "\\n\\n========\\n\\n"
            exit 1
        fi
        # end test that the AssignGenes.py igblast --format airr is ok
        # reorder names
        Rscript -e '
            args = commandArgs(trailingOnly=TRUE)
            db <- read.table(args[1], sep = "\\t", header = TRUE)
            reorder_names <- c("sequence_id", "rev_comp", "stop_codon", "vj_in_frame", "v_frameshift", "complete_vdj", "d_frame", "productive", "v_call", "d_call", "j_call", "c_call", "locus", "sequence", "sequence_alignment", "germline_alignment", "sequence_aa", "sequence_alignment_aa", "germline_alignment_aa", "v_alignment_start", "v_alignment_end", "d_alignment_start", "d_alignment_end", "j_alignment_start", "j_alignment_end", "c_alignment_start", "c_alignment_end", "v_sequence_alignment", "v_sequence_alignment_aa", "v_germline_alignment", "v_germline_alignment_aa", "d_sequence_alignment", "d_sequence_alignment_aa", "d_germline_alignment", "d_germline_alignment_aa", "j_sequence_alignment", "j_sequence_alignment_aa", "j_germline_alignment", "j_germline_alignment_aa", "c_sequence_alignment", "c_sequence_alignment_aa", "c_germline_alignment", "c_germline_alignment_aa", "fwr1", "fwr1_aa", "cdr1", "cdr1_aa", "fwr2", "fwr2_aa", "cdr2", "cdr2_aa", "fwr3", "fwr3_aa", "fwr4", "fwr4_aa", "cdr3", "cdr3_aa", "junction", "junction_length", "junction_aa", "junction_aa_length", "v_score", "d_score", "j_score", "c_score", "v_cigar", "d_cigar", "j_cigar", "c_cigar", "v_support", "d_support", "j_support", "c_support", "v_identity", "d_identity", "j_identity", "c_identity", "v_sequence_start", "v_sequence_end", "v_germline_start", "v_germline_end", "d_sequence_start", "d_sequence_end", "d_germline_start", "d_germline_end", "j_sequence_start", "j_sequence_end", "j_germline_start", "j_germline_end", "c_sequence_start", "c_sequence_end", "c_germline_start", "c_germline_end", "fwr1_start", "fwr1_end", "cdr1_start", "cdr1_end", "fwr2_start", "fwr2_end", "cdr2_start", "cdr2_end", "fwr3_start", "fwr3_end", "cdr3_start", "cdr3_end", "fwr4_start", "fwr4_end", "np1", "np1_length", "np2", "np2_length")
            if( ! (all(names(db) %in% reorder_names) & all(reorder_names %in% names(db)))){
            stop(paste0("\\n\\n================\\n\\nERROR IN Igblast_query PROCESS.\\nNAMES OF OUTPUT DATA BASE IS DIFFERENT FROM EXPECTED.\\nNAMES:\\n", sort(names(db)), "\\nEXPECTED:\\n", sort(reorder_names), "\\n\\n================\\n\\n"), call. = FALSE)
            }else{
                db <- db[ , match(reorder_names, names(db))]
                write.table(db, file = args[1], row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\\t")
            }
        ' \${FILE}_igblast.tsv |& tee -a igblast_report.log
        # end reorder names
        # add _with_gaps
        if [[ -s blast_format.tsv ]]; then # -s means MakeDb.py igblast has worked
            awk 'BEGIN{FS="\\t" ; ORS="" ; OFS=""}
                # means that work only on the first file
                FNR==NR{ 
                    if (FNR == 1){
                    # first line
                        SEQ_ALIGN_COL_NB="FALSE"
                        GERM_ALIGN_COL_NB="FALSE"
                        for(i4=1; i4<=NF; i4++){
                            if(\$i4=="sequence_alignment"){SEQ_ALIGN_COL_NB=i4}
                            if(\$i4=="germline_alignment"){GERM_ALIGN_COL_NB=i4}
                        }
                        if(SEQ_ALIGN_COL_NB=="FALSE"){
                            print "\\n\\n========\\n\\nERROR IN NEXTFLOW EXECUTION OF THE Igblast_query PROCESS\\n\\nNO sequence_alignment COLUMN NAME FOUND IN THE INPUT FILE\\n\\n========\\n\\n"
                            exit 1
                        }
                        if(GERM_ALIGN_COL_NB=="FALSE"){
                            print "\\n\\n========\\n\\nERROR IN NEXTFLOW EXECUTION OF THE Igblast_query PROCESS\\n\\nNO germline_alignment COLUMN NAME FOUND IN THE INPUT FILE\\n\\n========\\n\\n"
                            exit 1
                        }
                    }else{
                        gsub(/\\r/, "") 
                        # remove CR
                        SEQ_ALIGN=\$SEQ_ALIGN_COL_NB
                        GERM_ALIGN=\$GERM_ALIGN_COL_NB
                    }
                    next   # important!! skip processing in second block for first file
                }
                FNR!=NR {
                    # mean that works only for the second file
                    if (FNR == 1){ 
                        # first line
                        print \$0"\\tsequence_alignment_with_gaps\\tgermline_alignment_with_gaps\\n" > "with_gaps.tsv"
                    }else{
                        print \$0"\\t"SEQ_ALIGN"\\t"GERM_ALIGN"\\n" > "with_gaps.tsv"
                    }
                }
            ' blast_format.tsv ./\${FILE}_igblast.tsv |& tee -a igblast_report.log
        else
            awk 'BEGIN{FS="\\t" ; ORS="" ; OFS=""}
                FNR == 1{ 
                    print \$0"\\tsequence_alignment_with_gaps\\tgermline_alignment_with_gaps\\n" > "with_gaps.tsv"
                    next
                }{
                    print \$0"\\t\\t\\n" > "with_gaps.tsv"
                }
            ' ./\${FILE}_igblast.tsv |& tee -a igblast_report.log
        fi
        # end add _with_gaps
        # if no alignment
        ALIGNED=\$(
            awk 'BEGIN{FS="\\t"}
                NR==1{ 
                # first line
                PROD=="FALSE"
                    for(i4=1; i4<=NF; i4++){
                        if(\$i4=="productive"){PROD=i4}
                    }
                    if(PROD=="FALSE"){
                        print "\\n\\n========\\n\\nERROR IN NEXTFLOW EXECUTION OF THE Igblast_query PROCESS\\n\\nNO productive COLUMN NAME FOUND IN THE INPUT FILE\\n\\n========\\n\\n"
                        exit 1
                    }
                }
                NR==2{if(\$PROD == ""){print "FALSE"}else{print "TRUE"}}
            ' with_gaps.tsv
        )
        cp with_gaps.tsv igblast_unaligned_seq.tsv
        cp with_gaps.tsv igblast_aligned_seq.tsv
        if [[ "\$ALIGNED" == "FALSE" ]]; then
            sed -i '\$d' igblast_aligned_seq.tsv # delete the second (last) line
        else
            sed -i '\$d' igblast_unaligned_seq.tsv # delete the second (last) line
        fi
        # end if no alignment
    else
        echo \$expected > igblast_aligned_seq.tsv
        echo \$expected > igblast_unaligned_seq.tsv
    fi
    """
    // write ${} between "" to make a single argument when the variable is made of several values separated by a space. Otherwise, several arguments will be considered
}