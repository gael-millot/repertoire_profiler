
// Parse the tsv files generated by the igblast process to select the productive and unproductive sequences
// Output:
// - productive_seq_init.tsv: tsv file with the productive sequences
// - failed_productive_seq.tsv: tsv file with the unproductive sequences
process parseDb_filtering {
    label 'immcantation'
    cache 'true'

    input:
    path db_pass_ch // parallelization expected

    output:
    path "productive_seq_init.tsv", emit: productive_ch, optional: true
    path "failed_productive_seq.tsv", emit: unproductive_ch
    path "ParseDb_filtering.log", emit: parseDb_filtering_log_ch

    script:
    """
    #!/bin/bash -ue
    # set -o pipefail # inactivated because ParseDb.py returns error that are handled
    FILENAME=\$(basename -- "${db_pass_ch}") # recover a file name without path
    FILE=\${FILENAME%.*} # file name without extension
    echo -e "\\n\\n################################\\n\\n\$FILENAME\\n\\n################################\\n\\n" |& tee -a ParseDb_filtering.log
    if [[ -s ${db_pass_ch} ]]; then # -s means "exists and non empty". Thus, return FALSE is the file does not exists or is empty
        # ParseDb.py select -d ${db_pass_ch} -f productive -u TRUE T |& tee -a ParseDb_filtering.log
        ParseDb.py split -d ${db_pass_ch} -f productive |& tee -a ParseDb_filtering.log  # Used to create 2 files with content that depends of if the FALSE F or TRUE T value is found in the productive field (select command only creates a select file if values specifies in -u flag are found, in this case TRUE or T). If only F in the input file, _productive-T.tsv is not created
        if [ -s \${FILE}_productive-T.tsv ]; then
            cp \${FILE}_productive-T.tsv productive_seq_init.tsv |& tee -a ParseDb_filtering.log # can be empty file (only header)
        elif [ -s \${FILE}_productive-TRUE.tsv ]; then
            cp \${FILE}_productive-TRUE.tsv productive_seq_init.tsv |& tee -a ParseDb_filtering.log # can be empty file (only header)
        fi
        if [ -s \${FILE}_productive-F.tsv ]; then # see above for -s
            cp \${FILE}_productive-F.tsv failed_productive_seq.tsv |& tee -a ParseDb_filtering.log
        elif [ -s \${FILE}_productive-FALSE.tsv ]; then # if not TRUE or T, the value in the "productive" field can be either F or FALSE
            cp \${FILE}_productive-FALSE.tsv failed_productive_seq.tsv |& tee -a ParseDb_filtering.log
        elif [ -s \${FILE}_productive-NA.tsv ]; then # if not TRUE or T, the value in the "productive" field can be either F or FALSE
            cp \${FILE}_productive-NA.tsv failed_productive_seq.tsv |& tee -a ParseDb_filtering.log
        else
            echo -e "\\n\\nEMPTY failed_productive_seq.tsv FILE RETURNED FOLLOWING THE parseDb_filtering PROCESS\\n\\n" |& tee -a ParseDb_filtering.log
            # echo -n "" | cat > failed_productive_seq.tsv
            head -1 ${db_pass_ch} | cat > failed_productive_seq.tsv # only header in the file
        fi
    else
        echo -e "\\n\\n========\\n\\nINTERNAL ERROR IN NEXTFLOW EXECUTION\\n\\nEMPTY FILE GENERATED BY THE igblast PROCESS\\nCHECK THE ParseDb_filtering.log FILE IN THE report FOLDER INSIDE THE OUTPUT FOLDER\\n\\nPLEASE, REPORT AN ISSUE HERE https://gitlab.pasteur.fr/gmillot/repertoire_profiler/-/issues OR AT gael.millot<AT>pasteur.fr.\\n\\n========\\n\\n" # I said empty because the existence of the file has been checked after the igblast process
        exit 1
    fi
    """
}